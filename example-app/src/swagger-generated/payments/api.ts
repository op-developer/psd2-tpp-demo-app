// tslint:disable
/**
 * PSD2 Payment Initiation Service
 * __NOTE__: Calling PSD2 APIs with Postman is not supported at this time.   PSD2 Payment Initiation Service allows Third-Party Providers to create and submit SEPA payments. Check our [PSD2 page](/psd2) for more information about the APIs and the regulation.   Using this API requires authenticating the client application, and end user authentication and authorization.   [See the full workflow for PSD2 PIS API >](/p/paymentauthorizationflow)   If you encounter a **technical problem** with our PSD2 APIs, please [report the issue here](https://www.op.fi/private-customers/customer-service/report-a-problem). Include at least the following information: - System: __API Management__ - Service: __PSD2 Payments__ - Description of the issue: _Your description here_  ## Sandbox PSD2 APIs are available in sandbox free of charge for both licensed and unlicensed developers. You only need to [create a developer app](/developers/apps/create), [get test certificates](/p/psd2-tpp-setup) and [register](/p/psd2-tpp-setup#user-content-tpp-registration).  ## Production access Following the regulation, using PSD2 APIs is free of charge also in production. However, a Third-Party Provider has to apply for an AISP/PISP license from a financial authority (e.g. [FIN-FSA](https://www.finanssivalvonta.fi/en/regulation/regulatory-framework/psd2/) in Finland) and obtain valid [QWAC and QSEAL certificates](https://webgate.ec.europa.eu/tl-browser/#/). Once you have the necessary licenses and certificates, contact us at tpp-support@op.fi and we will send you instructions on how to start using the APIs in production.  ##Â General guidelines related to payments Guidelines for payments can be found in OP\'s site: https://www.op.fi/documents/20556/27664758/Countries+Bank+Details+C2B+SEPA+and+Cross-border+Payments/87860cbf-5a0a-c674-d65a-f3263c3141c5 Please note that this is a general guideline and some of the instructions can be payment type, service or channel specific and are not necessarily applicable to payments that are initiated through PSD2 Payments API.
 *
 * The version of the OpenAPI document: v1.1
 * Contact: tpp-support@op.fi
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    type: ApiErrorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    message: string;
    /**
     * Id of the error. Required on support requests.
     * @type {string}
     * @memberof ApiError
     */
    id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ApiErrorTypeEnum {
    SECURITY = 'SECURITY',
    VALIDATION = 'VALIDATION',
    TECHNICAL = 'TECHNICAL',
    BUSINESS = 'BUSINESS'
}

/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization {
    /**
     * Authorization bundle id
     * @type {string}
     * @memberof Authorization
     */
    authorizationId: string;
    /**
     * 
     * @type {Date}
     * @memberof Authorization
     */
    created: Date;
    /**
     * 
     * @type {Date}
     * @memberof Authorization
     */
    modified: Date;
    /**
     * 
     * @type {Date}
     * @memberof Authorization
     */
    authorized?: Date;
    /**
     * 
     * @type {AuthorizationStatus}
     * @memberof Authorization
     */
    status: AuthorizationStatus;
    /**
     * An array of SepaPaymentDetails (without submissions). Included only with query parameter `?include=payments`.
     * @type {Array<SepaPaymentDetails>}
     * @memberof Authorization
     */
    sepaPayments?: Array<SepaPaymentDetails>;
    /**
     * An array of ForeignPaymentDetails (without submissions). Included only with query parameter `?include=payments`.
     * @type {Array<ForeignPaymentDetails>}
     * @memberof Authorization
     */
    foreignPayments?: Array<ForeignPaymentDetails>;
}
/**
 * 
 * @export
 * @interface AuthorizationPayments
 */
export interface AuthorizationPayments {
    /**
     * An array of authorization bundle payments`.
     * @type {Array<SepaPaymentDetails | ForeignPaymentDetails>}
     * @memberof AuthorizationPayments
     */
    payments?: Array<SepaPaymentDetails | ForeignPaymentDetails>;
}
/**
 * Unauthorized = Request is pending for authorization by the PSU. Authorizing = PSU is at present authorizing the request. New payments can not be added to the authorization bundle. Authorized = PSU has authorized the request. Completed = Authorization has been consumed, i.e. payment has been submitted. Partially Revoked = Unsubmitted recurring or bundle payments have been revoked (some of the payments may have already been submitted and therefore they cannot be revoked). Revoked = Payment has bee revoked before it has been submitted.
 * @export
 * @enum {string}
 */
export enum AuthorizationStatus {
    Unauthorized = 'Unauthorized',
    Authorizing = 'Authorizing',
    Authorized = 'Authorized',
    Rejected = 'Rejected',
    Completed = 'Completed',
    PartiallyRevoked = 'PartiallyRevoked',
    Revoked = 'Revoked'
}

/**
 * Must specify either bic, clearing code or creditor address.
 * @export
 * @interface CreditorBicOrAddress
 */
export interface CreditorBicOrAddress {
    /**
     * 
     * @type {string}
     * @memberof CreditorBicOrAddress
     */
    type: CreditorBicOrAddressTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof CreditorBicOrAddress
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof CreditorBicOrAddress
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CreditorBicOrAddressTypeEnum {
    CreditorBicOrAddress = 'CreditorBicOrAddress'
}

/**
 * A payment with same idempotency key, client and user id is already created. If request body is equal to the original request and the status of that payment has not advanced beyond initial state, original payment is returned instead of this error.
 * @export
 * @interface DuplicatePayment
 */
export interface DuplicatePayment {
    /**
     * 
     * @type {string}
     * @memberof DuplicatePayment
     */
    type: DuplicatePaymentTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof DuplicatePayment
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof DuplicatePayment
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DuplicatePaymentTypeEnum {
    DuplicatePayment = 'DuplicatePayment'
}

/**
 * EU / ETA area payments must have valid bic and iban.
 * @export
 * @interface EuEtaValid
 */
export interface EuEtaValid {
    /**
     * 
     * @type {string}
     * @memberof EuEtaValid
     */
    type: EuEtaValidTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof EuEtaValid
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof EuEtaValid
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EuEtaValidTypeEnum {
    EuEtaValid = 'EuEtaValid'
}

/**
 * Given property must have none or exactly two decimals (i.e. cents).
 * @export
 * @interface EuroCents
 */
export interface EuroCents {
    /**
     * 
     * @type {string}
     * @memberof EuroCents
     */
    type: EuroCentsTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof EuroCents
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof EuroCents
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EuroCentsTypeEnum {
    EuroCents = 'EuroCents'
}

/**
 * Given property must be valid Finnish IBAN.
 * @export
 * @interface FinnishIban
 */
export interface FinnishIban {
    /**
     * 
     * @type {string}
     * @memberof FinnishIban
     */
    type: FinnishIbanTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof FinnishIban
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof FinnishIban
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FinnishIbanTypeEnum {
    FinnishIban = 'FinnishIban'
}

/**
 * Foreign address
 * @export
 * @interface ForeignAddress
 */
export interface ForeignAddress {
    /**
     * 
     * @type {string}
     * @memberof ForeignAddress
     */
    addressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof ForeignAddress
     */
    addressLine2?: string;
    /**
     * Country code according to ISO 3166, Alpha-2 code
     * @type {string}
     * @memberof ForeignAddress
     */
    country?: string;
}
/**
 * Foreign bank account, that can be in IBAN or BBAN format.
 * @export
 * @interface ForeignBankAccount
 */
export interface ForeignBankAccount {
    /**
     * Account number without formatting spaces. E.g. IBAN: FI9912345678901234 or BBAN: 12345678901234 IBAN format: [A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30} BBAN format: only numbers, max 35 char
     * @type {string}
     * @memberof ForeignBankAccount
     */
    id?: string;
    /**
     * IBAN or BBAN according to the account format
     * @type {string}
     * @memberof ForeignBankAccount
     */
    schemeName?: ForeignBankAccountSchemeNameEnum;
    /**
     * BICFI, BIC code of the bank
     * @type {string}
     * @memberof ForeignBankAccount
     */
    issuer?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ForeignBankAccountSchemeNameEnum {
    IBAN = 'IBAN',
    BBAN = 'BBAN'
}

/**
 * Address of the foreign bank. Address is mandatory if BICFI or Clearing System Id is not present.
 * @export
 * @interface ForeignBankAddress
 */
export interface ForeignBankAddress {
    /**
     * 
     * @type {string}
     * @memberof ForeignBankAddress
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ForeignBankAddress
     */
    city?: string;
    /**
     * Country code according to ISO 3166, Alpha-2 code
     * @type {string}
     * @memberof ForeignBankAddress
     */
    country?: string;
}
/**
 * Foreign bank account, that can be in IBAN or BBAN format.
 * @export
 * @interface ForeignFinancialInstitution
 */
export interface ForeignFinancialInstitution {
    /**
     * Payee\'s bank BIC-code (highly recommended)
     * @type {string}
     * @memberof ForeignFinancialInstitution
     */
    bic?: string;
    /**
     * Clearing system id (recommended if BIC not present). Not to be used with BIC.
     * @type {string}
     * @memberof ForeignFinancialInstitution
     */
    clearingSystemId?: string;
    /**
     * Name of the financial institution
     * @type {string}
     * @memberof ForeignFinancialInstitution
     */
    name?: string;
    /**
     * 
     * @type {ForeignBankAddress}
     * @memberof ForeignFinancialInstitution
     */
    foreignBankAddress?: ForeignBankAddress;
}
/**
 * Payee details for foreign payments.
 * @export
 * @interface ForeignPayee
 */
export interface ForeignPayee {
    /**
     * 
     * @type {ForeignBankAccount}
     * @memberof ForeignPayee
     */
    bankAccount: ForeignBankAccount;
    /**
     * Name of the payee
     * @type {string}
     * @memberof ForeignPayee
     */
    name: string;
    /**
     * 
     * @type {ForeignFinancialInstitution}
     * @memberof ForeignPayee
     */
    financialInstitution: ForeignFinancialInstitution;
    /**
     * 
     * @type {ForeignAddress}
     * @memberof ForeignPayee
     */
    foreignAddress: ForeignAddress;
}
/**
 * 
 * @export
 * @interface ForeignPaymentDetails
 */
export interface ForeignPaymentDetails {
    /**
     * Charge bearer. If not given, then default value of SHA will be used. SHA (default/recommended) = both parties pay their own banking fees OUR = payer pays all the banking fees
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    detailsOfCharges?: ForeignPaymentDetailsDetailsOfChargesEnum;
    /**
     * Foreign payment type code. NORM (default) = regular foreign payment HIGH = urgent foreign payment
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    paymentOrder?: ForeignPaymentDetailsPaymentOrderEnum;
    /**
     * Positive (greater-than zero) monetary amount.
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    amount?: string;
    /**
     * ISO 4127 currency code
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    currency?: string;
    /**
     * 
     * @type {ForeignPayee}
     * @memberof ForeignPaymentDetails
     */
    payee?: ForeignPayee;
    /**
     * 
     * @type {ForeignPaymentRequestPayer}
     * @memberof ForeignPaymentDetails
     */
    payer?: ForeignPaymentRequestPayer;
    /**
     * Message for the payee and payer\'s account statement
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    message?: string;
    /**
     * Reference number related to the FX deal for the payment amount. If given, then exchange rate according to the FX deal is used (FX deal = Foreign currency exchange deal). If not given then bank will use the daily exchange rates.
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    exchangeRateReference?: string;
    /**
     * 
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    authorizationId?: string;
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    paymentId?: string;
    /**
     * Payment type. Always \'ForeignPayment\' for foreign payments.
     * @type {string}
     * @memberof ForeignPaymentDetails
     */
    paymentType?: string;
    /**
     * Number of recurring payments. Foreign payment is always 1 (single payment).
     * @type {number}
     * @memberof ForeignPaymentDetails
     */
    count?: number;
    /**
     * 
     * @type {Date}
     * @memberof ForeignPaymentDetails
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ForeignPaymentDetails
     */
    modified?: Date;
    /**
     * 
     * @type {AuthorizationStatus}
     * @memberof ForeignPaymentDetails
     */
    status?: AuthorizationStatus;
    /**
     * An array of Submissions. Included only with query parameter `?include=submissions`.
     * @type {Array<Submission>}
     * @memberof ForeignPaymentDetails
     */
    submissions?: Array<Submission>;
}

/**
    * @export
    * @enum {string}
    */
export enum ForeignPaymentDetailsDetailsOfChargesEnum {
    SHA = 'SHA',
    OUR = 'OUR'
}
/**
    * @export
    * @enum {string}
    */
export enum ForeignPaymentDetailsPaymentOrderEnum {
    NORM = 'NORM',
    HIGH = 'HIGH'
}

/**
 * 
 * @export
 * @interface ForeignPaymentRequest
 */
export interface ForeignPaymentRequest {
    /**
     * Charge bearer. If not given, then default value of SHA will be used. SHA (default/recommended) = both parties pay their own banking fees OUR = payer pays all the banking fees
     * @type {string}
     * @memberof ForeignPaymentRequest
     */
    detailsOfCharges?: ForeignPaymentRequestDetailsOfChargesEnum;
    /**
     * Foreign payment type code. NORM (default) = regular foreign payment HIGH = urgent foreign payment
     * @type {string}
     * @memberof ForeignPaymentRequest
     */
    paymentOrder?: ForeignPaymentRequestPaymentOrderEnum;
    /**
     * Positive (greater-than zero) monetary amount.
     * @type {string}
     * @memberof ForeignPaymentRequest
     */
    amount: string;
    /**
     * ISO 4127 currency code
     * @type {string}
     * @memberof ForeignPaymentRequest
     */
    currency: string;
    /**
     * 
     * @type {ForeignPayee}
     * @memberof ForeignPaymentRequest
     */
    payee: ForeignPayee;
    /**
     * 
     * @type {ForeignPaymentRequestPayer}
     * @memberof ForeignPaymentRequest
     */
    payer?: ForeignPaymentRequestPayer;
    /**
     * Message for the payee and payer\'s account statement
     * @type {string}
     * @memberof ForeignPaymentRequest
     */
    message: string;
    /**
     * Reference number related to the FX deal for the payment amount. If given, then exchange rate according to the FX deal is used (FX deal = Foreign currency exchange deal). If not given then bank will use the daily exchange rates.
     * @type {string}
     * @memberof ForeignPaymentRequest
     */
    exchangeRateReference?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ForeignPaymentRequestDetailsOfChargesEnum {
    SHA = 'SHA',
    OUR = 'OUR'
}
/**
    * @export
    * @enum {string}
    */
export enum ForeignPaymentRequestPaymentOrderEnum {
    NORM = 'NORM',
    HIGH = 'HIGH'
}

/**
 * 
 * @export
 * @interface ForeignPaymentRequestPayer
 */
export interface ForeignPaymentRequestPayer {
    /**
     * For SEPA-payments the payee\'s account number must always be in IBAN format without formatting spaces. E.g. FI9912345678901234 IBAN pattern: [A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}
     * @type {string}
     * @memberof ForeignPaymentRequestPayer
     */
    iban: string;
}
/**
 * Action (i.e. state transition) is not allowed.
 * @export
 * @interface IllegalState
 */
export interface IllegalState {
    /**
     * 
     * @type {string}
     * @memberof IllegalState
     */
    type: IllegalStateTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof IllegalState
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof IllegalState
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IllegalStateTypeEnum {
    IllegalState = 'IllegalState'
}

/**
 * Payer account has insufficient funds for payment.
 * @export
 * @interface InsufficientFunds
 */
export interface InsufficientFunds {
    /**
     * 
     * @type {string}
     * @memberof InsufficientFunds
     */
    type: InsufficientFundsTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof InsufficientFunds
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof InsufficientFunds
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InsufficientFundsTypeEnum {
    InsufficientFunds = 'InsufficientFunds'
}

/**
 * Property value is not valid.
 * @export
 * @interface InvalidValue
 */
export interface InvalidValue {
    /**
     * 
     * @type {string}
     * @memberof InvalidValue
     */
    type: InvalidValueTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof InvalidValue
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidValue
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InvalidValueTypeEnum {
    InvalidValue = 'InvalidValue'
}

/**
 * Given property must be a) less-than `value` if `inclusive` is false or b) less-than-or-equal `value` if `inclusive` is true.
 * @export
 * @interface Max
 */
export interface Max {
    /**
     * 
     * @type {string}
     * @memberof Max
     */
    type: MaxTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof Max
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof Max
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Max
     */
    value: string;
    /**
     * 
     * @type {boolean}
     * @memberof Max
     */
    inclusive: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum MaxTypeEnum {
    Max = 'Max'
}

/**
 * Must specify either message or reference.
 * @export
 * @interface MessageOrReference
 */
export interface MessageOrReference {
    /**
     * 
     * @type {string}
     * @memberof MessageOrReference
     */
    type: MessageOrReferenceTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof MessageOrReference
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageOrReference
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageOrReferenceTypeEnum {
    MessageOrReference = 'MessageOrReference'
}

/**
 * Given property must be a) greater-than `value` if `inclusive` is false or b) greater-than-or-equal `value` if `inclusive` is true.
 * @export
 * @interface Min
 */
export interface Min {
    /**
     * 
     * @type {string}
     * @memberof Min
     */
    type: MinTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof Min
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof Min
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Min
     */
    value: string;
    /**
     * 
     * @type {boolean}
     * @memberof Min
     */
    inclusive: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum MinTypeEnum {
    Min = 'Min'
}

/**
 * Payment submission has failed because of one business reason or another, e.g. withdrawal limits, non-existing or non-accessible payee account, account permissions. See message for details.
 * @export
 * @interface PaymentFail
 */
export interface PaymentFail {
    /**
     * 
     * @type {string}
     * @memberof PaymentFail
     */
    type: PaymentFailTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof PaymentFail
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentFail
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentFailTypeEnum {
    PaymentFail = 'PaymentFail'
}

/**
 * Payment order value is invalid.
 * @export
 * @interface PaymentOrder
 */
export interface PaymentOrder {
    /**
     * 
     * @type {string}
     * @memberof PaymentOrder
     */
    type: PaymentOrderTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof PaymentOrder
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentOrder
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentOrderTypeEnum {
    PaymentOrder = 'PaymentOrder'
}

/**
 * 
 * @export
 * @interface PaymentSubmissions
 */
export interface PaymentSubmissions {
    /**
     * 
     * @type {Array<Submission>}
     * @memberof PaymentSubmissions
     */
    submissions?: Array<Submission>;
}
/**
 * 
 * @export
 * @interface Required
 */
export interface Required {
    /**
     * Error type.
     * @type {string}
     * @memberof Required
     */
    type: RequiredTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof Required
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof Required
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RequiredTypeEnum {
    Required = 'Required'
}

/**
 * Given if address is set, may not contain blank or empty strings.
 * @export
 * @interface SepaAddress
 */
export interface SepaAddress {
    /**
     * 
     * @type {string}
     * @memberof SepaAddress
     */
    type: SepaAddressTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof SepaAddress
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof SepaAddress
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SepaAddressTypeEnum {
    SepaAddress = 'SepaAddress'
}

/**
 * Given value must be a valid SEPA IBAN.
 * @export
 * @interface SepaIban
 */
export interface SepaIban {
    /**
     * 
     * @type {string}
     * @memberof SepaIban
     */
    type: SepaIbanTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof SepaIban
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof SepaIban
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SepaIbanTypeEnum {
    SepaIban = 'SepaIban'
}

/**
 * Payee details. For non-domestic payments (i.e. IBAN not starting with `FI`) `address` and `country` are required.
 * @export
 * @interface SepaPayee
 */
export interface SepaPayee {
    /**
     * For SEPA-payments the payee\'s account number must always be in IBAN format without formatting spaces. E.g. FI9912345678901234 IBAN pattern: [A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}
     * @type {string}
     * @memberof SepaPayee
     */
    iban: string;
    /**
     * Name of the payee
     * @type {string}
     * @memberof SepaPayee
     */
    name: string;
    /**
     * Information that locates and identifies a specific address, as defined by postal services, presented in free format text. Max 4 address lines, max length 35 per address line
     * @type {Array<string>}
     * @memberof SepaPayee
     */
    address?: Array<string>;
    /**
     * ISO 3166-1 alpha-2 country code
     * @type {string}
     * @memberof SepaPayee
     */
    country?: string;
}
/**
 * 
 * @export
 * @interface SepaPaymentDetails
 */
export interface SepaPaymentDetails {
    /**
     * Authorization bundle id. Used to bundle several payments to one authorization. Foreign payments can\'t be bundled with SEPA payments.
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    authorizationId?: string;
    /**
     * Positive (greater-than zero) monetary amount. Currency is EUR.
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    amountEUR?: string;
    /**
     * Defines the recurrence of the payment. Default value is 1, i.e. single payment. If the value is higher than 1, then the payment is considered as recurring payment to the same payee with the same amount. Payment can be repeatedly submitted according to the number in count element.
     * @type {number}
     * @memberof SepaPaymentDetails
     */
    count?: number;
    /**
     * 
     * @type {SepaPayee}
     * @memberof SepaPaymentDetails
     */
    payee?: SepaPayee;
    /**
     * 
     * @type {SepaPaymentRequestPayer}
     * @memberof SepaPaymentDetails
     */
    payer?: SepaPaymentRequestPayer;
    /**
     * Message for the payee and payer\'s account statement
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    reference?: string;
    /**
     * Name of the ultimate payee aka ultimate creditor
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    ultimatePayee?: string;
    /**
     * Name of the original payer aka ultimate debtor
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    originalPayer?: string;
    /**
     * Unique identifier for the payment.
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    paymentId?: string;
    /**
     * Payment type. Always \'SepaPayment\' for SEPA payments.
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    paymentType?: string;
    /**
     * 
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    detailsOfCharges?: SepaPaymentDetailsDetailsOfChargesEnum;
    /**
     * 
     * @type {string}
     * @memberof SepaPaymentDetails
     */
    paymentOrder?: SepaPaymentDetailsPaymentOrderEnum;
    /**
     * 
     * @type {Date}
     * @memberof SepaPaymentDetails
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SepaPaymentDetails
     */
    modified?: Date;
    /**
     * 
     * @type {AuthorizationStatus}
     * @memberof SepaPaymentDetails
     */
    status?: AuthorizationStatus;
    /**
     * An array of Submissions. Included only with query parameter `?include=submissions`.
     * @type {Array<Submission>}
     * @memberof SepaPaymentDetails
     */
    submissions?: Array<Submission>;
}

/**
    * @export
    * @enum {string}
    */
export enum SepaPaymentDetailsDetailsOfChargesEnum {
    SHA = 'SHA'
}
/**
    * @export
    * @enum {string}
    */
export enum SepaPaymentDetailsPaymentOrderEnum {
    SEPA = 'SEPA',
    SEPAINST = 'SEPA_INST'
}

/**
 * 
 * @export
 * @interface SepaPaymentRequest
 */
export interface SepaPaymentRequest {
    /**
     * Authorization bundle id. Used to bundle several payments to one authorization. Foreign payments can\'t be bundled with SEPA payments.
     * @type {string}
     * @memberof SepaPaymentRequest
     */
    authorizationId?: string;
    /**
     * Positive (greater-than zero) monetary amount. Currency is EUR.
     * @type {string}
     * @memberof SepaPaymentRequest
     */
    amountEUR: string;
    /**
     * Defines the recurrence of the payment. Default value is 1, i.e. single payment. If the value is higher than 1, then the payment is considered as recurring payment to the same payee with the same amount. Payment can be repeatedly submitted according to the number in count element.
     * @type {number}
     * @memberof SepaPaymentRequest
     */
    count?: number;
    /**
     * 
     * @type {SepaPayee}
     * @memberof SepaPaymentRequest
     */
    payee: SepaPayee;
    /**
     * 
     * @type {SepaPaymentRequestPayer}
     * @memberof SepaPaymentRequest
     */
    payer?: SepaPaymentRequestPayer;
    /**
     * Message for the payee and payer\'s account statement
     * @type {string}
     * @memberof SepaPaymentRequest
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof SepaPaymentRequest
     */
    reference?: string;
    /**
     * Name of the ultimate payee aka ultimate creditor
     * @type {string}
     * @memberof SepaPaymentRequest
     */
    ultimatePayee?: string;
    /**
     * Name of the original payer aka ultimate debtor
     * @type {string}
     * @memberof SepaPaymentRequest
     */
    originalPayer?: string;
}
/**
 * Payer element is used to define the debit account. If the debit account is not given in the request, then the PSU must choose the debit account from an account list presented by the ASPSP on the authentication and authorization. PSU always has the option to change the debit account during authorization flow.
 * @export
 * @interface SepaPaymentRequestPayer
 */
export interface SepaPaymentRequestPayer {
    /**
     * For SEPA-payments the payee\'s account number must always be in IBAN format without formatting spaces. E.g. FI9912345678901234 IBAN pattern: [A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}
     * @type {string}
     * @memberof SepaPaymentRequestPayer
     */
    iban: string;
}
/**
 * Given property must be of size between `min` and `max`.
 * @export
 * @interface Size
 */
export interface Size {
    /**
     * 
     * @type {string}
     * @memberof Size
     */
    type: SizeTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof Size
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof Size
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof Size
     */
    min: number;
    /**
     * 
     * @type {number}
     * @memberof Size
     */
    max: number;
}

/**
    * @export
    * @enum {string}
    */
export enum SizeTypeEnum {
    Size = 'Size'
}

/**
 * 
 * @export
 * @interface Submission
 */
export interface Submission {
    /**
     * 
     * @type {string}
     * @memberof Submission
     */
    submissionId?: string;
    /**
     * Archive id (\"Arkistointitunnus\").
     * @type {string}
     * @memberof Submission
     */
    archiveId?: string;
    /**
     * 
     * @type {Date}
     * @memberof Submission
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Submission
     */
    modified?: Date;
    /**
     * Submission status: * `Accepted`: payment has been accepted for processing. It may still be rejected at later stage if it can\'t be processed.   Resubmitting payment with same `submissionId` will return the same result without actually making a duplicate payment.  * `Pending`: payment is pending. It has not been debited from the account. Payment may end up in this state due to technical error.   Resubmission with same `submissionId` is possible until midnight (Europe/Helsinki timezone).  * `Error`: submission resulted in error, e.g. because of insufficient funds. Payment maybe resubmitted with same `submissionId` later. * `Submitted`: payment has been submitted successfully, i.e. debited from the payer\'s account. Resubmitting payment with same `submissionId`   will return the same result without actually making a duplicate payment.  * `Credited`: payment has been submitted and credited successfully, i.e. debited from the payer\'s account and credited on payee\'s account. This status is used with SEPA Inst payments. * `Rejected`: payment has been rejected and it can\'t be processed further. Payer\'s account has not been debited. 
     * @type {string}
     * @memberof Submission
     */
    status?: SubmissionStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SubmissionStatusEnum {
    Accepted = 'Accepted',
    Pending = 'Pending',
    Error = 'Error',
    Submitted = 'Submitted',
    Credited = 'Credited',
    Rejected = 'Rejected'
}

/**
 * Property cannot be parsed into valid type.
 * @export
 * @interface TypeMismatch
 */
export interface TypeMismatch {
    /**
     * 
     * @type {string}
     * @memberof TypeMismatch
     */
    type: TypeMismatchTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof TypeMismatch
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof TypeMismatch
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TypeMismatchTypeEnum {
    TypeMismatch = 'TypeMismatch'
}

/**
 * Given property is not recognized and should be ommited on the request.
 * @export
 * @interface UnrecognizedProperty
 */
export interface UnrecognizedProperty {
    /**
     * 
     * @type {string}
     * @memberof UnrecognizedProperty
     */
    type: UnrecognizedPropertyTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof UnrecognizedProperty
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof UnrecognizedProperty
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UnrecognizedPropertyTypeEnum {
    UnrecognizedProperty = 'UnrecognizedProperty'
}

/**
 * Given bic must be in valid format.
 * @export
 * @interface ValidBic
 */
export interface ValidBic {
    /**
     * 
     * @type {string}
     * @memberof ValidBic
     */
    type: ValidBicTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidBic
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidBic
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidBicTypeEnum {
    ValidBic = 'ValidBic'
}

/**
 * Given property must be valid ISO 3166-1 alpha-2 country code
 * @export
 * @interface ValidCountryCode
 */
export interface ValidCountryCode {
    /**
     * 
     * @type {string}
     * @memberof ValidCountryCode
     */
    type: ValidCountryCodeTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidCountryCode
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidCountryCode
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidCountryCodeTypeEnum {
    CountryCode = 'CountryCode'
}

/**
 * Sepa payment details of charges must be SHA.
 * @export
 * @interface ValidDetailOfCharges
 */
export interface ValidDetailOfCharges {
    /**
     * 
     * @type {string}
     * @memberof ValidDetailOfCharges
     */
    type: ValidDetailOfChargesTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidDetailOfCharges
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidDetailOfCharges
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidDetailOfChargesTypeEnum {
    ValidDetailOfCharges = 'ValidDetailOfCharges'
}

/**
 * Given property must be either a valid RF Creditor Reference or Finnish domestic reference number.
 * @export
 * @interface ValidFinnishReference
 */
export interface ValidFinnishReference {
    /**
     * 
     * @type {string}
     * @memberof ValidFinnishReference
     */
    type: ValidFinnishReferenceTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidFinnishReference
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidFinnishReference
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidFinnishReferenceTypeEnum {
    FinnishReference = 'FinnishReference'
}

/**
 * Foreign payment can not have recurrence. Only single payments are supported.
 * @export
 * @interface ValidForeignPaymentRecurrence
 */
export interface ValidForeignPaymentRecurrence {
    /**
     * 
     * @type {string}
     * @memberof ValidForeignPaymentRecurrence
     */
    type: ValidForeignPaymentRecurrenceTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidForeignPaymentRecurrence
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidForeignPaymentRecurrence
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidForeignPaymentRecurrenceTypeEnum {
    ValidForeignPaymentRecurrence = 'ValidForeignPaymentRecurrence'
}

/**
 * Given property must be a valid IBAN.
 * @export
 * @interface ValidIban
 */
export interface ValidIban {
    /**
     * 
     * @type {string}
     * @memberof ValidIban
     */
    type: ValidIbanTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidIban
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidIban
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidIbanTypeEnum {
    Iban = 'Iban'
}

/**
 * Payment order value is not valid for this type of payment.
 * @export
 * @interface ValidPaymentOrder
 */
export interface ValidPaymentOrder {
    /**
     * 
     * @type {string}
     * @memberof ValidPaymentOrder
     */
    type: ValidPaymentOrderTypeEnum;
    /**
     * Path of property in error.
     * @type {string}
     * @memberof ValidPaymentOrder
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidPaymentOrder
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ValidPaymentOrderTypeEnum {
    ValidPaymentOrder = 'ValidPaymentOrder'
}


/**
 * ForeignPaymentsApi - axios parameter creator
 * @export
 */
export const ForeignPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow  Foreign payment initiation rules:   * Foreign payments must always be initiated as single payment, i.e. one at a time, and the PISP must submit the payment immediately after the PSU has confirmed the payment request.   * Foreign payments cannot be recurring payments, i.e. paid repeatedly with the same amount and to the same payee.   * Foreign payments cannot be part of a bundle either, i.e. several foreign payments included in the request. If the PSU wants to initiate several foreign payments, then each payment must be initiated, confirmed and submitted separately. 
         * @summary Create Foreign payment
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {ForeignPaymentRequest} [foreignPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForeignPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, foreignPaymentRequest?: ForeignPaymentRequest, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling createForeignPayment.');
            }
            // verify required parameter 'xIdempotencyKey' is not null or undefined
            if (xIdempotencyKey === null || xIdempotencyKey === undefined) {
                throw new RequiredError('xIdempotencyKey','Required parameter xIdempotencyKey was null or undefined when calling createForeignPayment.');
            }
            const localVarPath = `/foreign-payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof foreignPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(foreignPaymentRequest !== undefined ? foreignPaymentRequest : {}) : (foreignPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete foreign payment before it\'s submitted
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling deleteForeignPayment.');
            }
            const localVarPath = `/foreign-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find payments by authorizationId
         * @param {string} authorizationId Authorization ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling findPaymentsByAuthorizationId.');
            }
            const localVarPath = `/authorizations/{authorizationId}/payments`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling getAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAuthorization.');
            }
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get foreign payment details
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getForeignPayment.');
            }
            const localVarPath = `/foreign-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get foreign payment submission
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForeignSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options: any = {}): RequestArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getForeignSubmission.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getForeignSubmission.');
            }
            const localVarPath = `/foreign-payments/{paymentId}/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            if (xSandboxScenario !== undefined && xSandboxScenario !== null) {
                localVarHeaderParameter['x-sandbox-scenario'] = String(xSandboxScenario);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List foreign payment submissions
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForeignSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling listForeignSubmissions.');
            }
            const localVarPath = `/foreign-payments/{paymentId}/submissions`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
         * @summary Revoke authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling revokeAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling revokeAuthorization.');
            }
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit foreign payment
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForeignPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options: any = {}): RequestArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submitForeignPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling submitForeignPayment.');
            }
            const localVarPath = `/foreign-payments/{paymentId}/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            if (xSandboxScenario !== undefined && xSandboxScenario !== null) {
                localVarHeaderParameter['x-sandbox-scenario'] = String(xSandboxScenario);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ForeignPaymentsApi - functional programming interface
 * @export
 */
export const ForeignPaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow  Foreign payment initiation rules:   * Foreign payments must always be initiated as single payment, i.e. one at a time, and the PISP must submit the payment immediately after the PSU has confirmed the payment request.   * Foreign payments cannot be recurring payments, i.e. paid repeatedly with the same amount and to the same payee.   * Foreign payments cannot be part of a bundle either, i.e. several foreign payments included in the request. If the PSU wants to initiate several foreign payments, then each payment must be initiated, confirmed and submitted separately. 
         * @summary Create Foreign payment
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {ForeignPaymentRequest} [foreignPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForeignPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, foreignPaymentRequest?: ForeignPaymentRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForeignPaymentDetails> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).createForeignPayment(authorization, xIdempotencyKey, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, foreignPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete foreign payment before it\'s submitted
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForeignPaymentDetails> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).deleteForeignPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Find payments by authorizationId
         * @param {string} authorizationId Authorization ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationPayments> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).findPaymentsByAuthorizationId(authorizationId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get payment authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).getAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get foreign payment details
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForeignPaymentDetails> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).getForeignPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get foreign payment submission
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForeignSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).getForeignSubmission(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List foreign payment submissions
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForeignSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSubmissions> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).listForeignSubmissions(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
         * @summary Revoke authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).revokeAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit foreign payment
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForeignPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission> {
            const localVarAxiosArgs = ForeignPaymentsApiAxiosParamCreator(configuration).submitForeignPayment(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ForeignPaymentsApi - factory interface
 * @export
 */
export const ForeignPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow  Foreign payment initiation rules:   * Foreign payments must always be initiated as single payment, i.e. one at a time, and the PISP must submit the payment immediately after the PSU has confirmed the payment request.   * Foreign payments cannot be recurring payments, i.e. paid repeatedly with the same amount and to the same payee.   * Foreign payments cannot be part of a bundle either, i.e. several foreign payments included in the request. If the PSU wants to initiate several foreign payments, then each payment must be initiated, confirmed and submitted separately. 
         * @summary Create Foreign payment
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {ForeignPaymentRequest} [foreignPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForeignPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, foreignPaymentRequest?: ForeignPaymentRequest, options?: any) {
            return ForeignPaymentsApiFp(configuration).createForeignPayment(authorization, xIdempotencyKey, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, foreignPaymentRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete foreign payment before it\'s submitted
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).deleteForeignPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Find payments by authorizationId
         * @param {string} authorizationId Authorization ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).findPaymentsByAuthorizationId(authorizationId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get payment authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).getAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get foreign payment details
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).getForeignPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get foreign payment submission
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForeignSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).getForeignSubmission(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, options)(axios, basePath);
        },
        /**
         * 
         * @summary List foreign payment submissions
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForeignSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).listForeignSubmissions(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
         * @summary Revoke authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return ForeignPaymentsApiFp(configuration).revokeAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Submit foreign payment
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForeignPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options?: any) {
            return ForeignPaymentsApiFp(configuration).submitForeignPayment(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, body, options)(axios, basePath);
        },
    };
};

/**
 * ForeignPaymentsApi - object-oriented interface
 * @export
 * @class ForeignPaymentsApi
 * @extends {BaseAPI}
 */
export class ForeignPaymentsApi extends BaseAPI {
    /**
     * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow  Foreign payment initiation rules:   * Foreign payments must always be initiated as single payment, i.e. one at a time, and the PISP must submit the payment immediately after the PSU has confirmed the payment request.   * Foreign payments cannot be recurring payments, i.e. paid repeatedly with the same amount and to the same payee.   * Foreign payments cannot be part of a bundle either, i.e. several foreign payments included in the request. If the PSU wants to initiate several foreign payments, then each payment must be initiated, confirmed and submitted separately. 
     * @summary Create Foreign payment
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
     * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
     * @param {string} [xApiKey] API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {ForeignPaymentRequest} [foreignPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public createForeignPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, foreignPaymentRequest?: ForeignPaymentRequest, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).createForeignPayment(authorization, xIdempotencyKey, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, foreignPaymentRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete foreign payment before it\'s submitted
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public deleteForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).deleteForeignPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Find payments by authorizationId
     * @param {string} authorizationId Authorization ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).findPaymentsByAuthorizationId(authorizationId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get payment authorization (bundle)
     * @param {string} authorizationId Authorization ID
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
     * @param {string} [xApiKey] API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).getAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get foreign payment details
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public getForeignPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).getForeignPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get foreign payment submission
     * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public getForeignSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).getForeignSubmission(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List foreign payment submissions
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public listForeignSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).listForeignSubmissions(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
     * @summary Revoke authorization (bundle)
     * @param {string} authorizationId Authorization ID
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
     * @param {string} [xApiKey] API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).revokeAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Submit foreign payment
     * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ForeignPaymentsApi
     */
    public submitForeignPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options?: any) {
        return ForeignPaymentsApiFp(this.configuration).submitForeignPayment(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, body, options)(this.axios, this.basePath);
    }

}


/**
 * SEPAPaymentsApi - axios parameter creator
 * @export
 */
export const SEPAPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow 
         * @summary Create SEPA payment
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {SepaPaymentRequest} [sepaPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSepaPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, sepaPaymentRequest?: SepaPaymentRequest, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling createSepaPayment.');
            }
            // verify required parameter 'xIdempotencyKey' is not null or undefined
            if (xIdempotencyKey === null || xIdempotencyKey === undefined) {
                throw new RequiredError('xIdempotencyKey','Required parameter xIdempotencyKey was null or undefined when calling createSepaPayment.');
            }
            const localVarPath = `/sepa-payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof sepaPaymentRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(sepaPaymentRequest !== undefined ? sepaPaymentRequest : {}) : (sepaPaymentRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete SEPA payment before it\'s submitted
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling deleteSepaPayment.');
            }
            const localVarPath = `/sepa-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find payments by authorizationId
         * @param {string} authorizationId Authorization ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling findPaymentsByAuthorizationId.');
            }
            const localVarPath = `/authorizations/{authorizationId}/payments`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payment authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling getAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAuthorization.');
            }
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SEPA payment details
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getSepaPayment.');
            }
            const localVarPath = `/sepa-payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SEPA submission
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSepaSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options: any = {}): RequestArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getSepaSubmission.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling getSepaSubmission.');
            }
            const localVarPath = `/sepa-payments/{paymentId}/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            if (xSandboxScenario !== undefined && xSandboxScenario !== null) {
                localVarHeaderParameter['x-sandbox-scenario'] = String(xSandboxScenario);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List SEPA payment submissions
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSepaSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling listSepaSubmissions.');
            }
            const localVarPath = `/sepa-payments/{paymentId}/submissions`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
         * @summary Revoke authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling revokeAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling revokeAuthorization.');
            }
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit SEPA payment
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSepaPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options: any = {}): RequestArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling submitSepaPayment.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling submitSepaPayment.');
            }
            const localVarPath = `/sepa-payments/{paymentId}/submissions/{submissionId}`
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            if (xSandboxScenario !== undefined && xSandboxScenario !== null) {
                localVarHeaderParameter['x-sandbox-scenario'] = String(xSandboxScenario);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SEPAPaymentsApi - functional programming interface
 * @export
 */
export const SEPAPaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow 
         * @summary Create SEPA payment
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {SepaPaymentRequest} [sepaPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSepaPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, sepaPaymentRequest?: SepaPaymentRequest, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SepaPaymentDetails> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).createSepaPayment(authorization, xIdempotencyKey, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, sepaPaymentRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete SEPA payment before it\'s submitted
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SepaPaymentDetails> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).deleteSepaPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Find payments by authorizationId
         * @param {string} authorizationId Authorization ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationPayments> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).findPaymentsByAuthorizationId(authorizationId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get payment authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).getAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get SEPA payment details
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SepaPaymentDetails> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).getSepaPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get SEPA submission
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSepaSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).getSepaSubmission(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List SEPA payment submissions
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSepaSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSubmissions> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).listSepaSubmissions(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
         * @summary Revoke authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).revokeAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Submit SEPA payment
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSepaPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Submission> {
            const localVarAxiosArgs = SEPAPaymentsApiAxiosParamCreator(configuration).submitSepaPayment(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SEPAPaymentsApi - factory interface
 * @export
 */
export const SEPAPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow 
         * @summary Create SEPA payment
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {SepaPaymentRequest} [sepaPaymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSepaPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, sepaPaymentRequest?: SepaPaymentRequest, options?: any) {
            return SEPAPaymentsApiFp(configuration).createSepaPayment(authorization, xIdempotencyKey, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, sepaPaymentRequest, options)(axios, basePath);
        },
        /**
         * 
         * @summary Delete SEPA payment before it\'s submitted
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).deleteSepaPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Find payments by authorizationId
         * @param {string} authorizationId Authorization ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).findPaymentsByAuthorizationId(authorizationId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get payment authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).getAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get SEPA payment details
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).getSepaPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get SEPA submission
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSepaSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).getSepaSubmission(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, options)(axios, basePath);
        },
        /**
         * 
         * @summary List SEPA payment submissions
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSepaSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).listSepaSubmissions(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
         * @summary Revoke authorization (bundle)
         * @param {string} authorizationId Authorization ID
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
         * @param {string} [xApiKey] API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return SEPAPaymentsApiFp(configuration).revokeAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Submit SEPA payment
         * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
         * @param {string} paymentId Payment ID
         * @param {string} [xApiKey] API Key
         * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
         * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSepaPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options?: any) {
            return SEPAPaymentsApiFp(configuration).submitSepaPayment(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, body, options)(axios, basePath);
        },
    };
};

/**
 * SEPAPaymentsApi - object-oriented interface
 * @export
 * @class SEPAPaymentsApi
 * @extends {BaseAPI}
 */
export class SEPAPaymentsApi extends BaseAPI {
    /**
     * Detailed workflow description of the payment initiation process can be found at https://op-developer.fi/p/paymentauthorizationflow 
     * @summary Create SEPA payment
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
     * @param {string} xIdempotencyKey Every payment will be created only once per x-idempotency-key.
     * @param {string} [xApiKey] API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {SepaPaymentRequest} [sepaPaymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public createSepaPayment(authorization: string, xIdempotencyKey: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, sepaPaymentRequest?: SepaPaymentRequest, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).createSepaPayment(authorization, xIdempotencyKey, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, sepaPaymentRequest, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Delete SEPA payment before it\'s submitted
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public deleteSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).deleteSepaPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Find payments by authorizationId
     * @param {string} authorizationId Authorization ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public findPaymentsByAuthorizationId(authorizationId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).findPaymentsByAuthorizationId(authorizationId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get payment authorization (bundle)
     * @param {string} authorizationId Authorization ID
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
     * @param {string} [xApiKey] API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public getAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).getAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get SEPA payment details
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public getSepaPayment(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).getSepaPayment(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get SEPA submission
     * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public getSepaSubmission(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).getSepaSubmission(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List SEPA payment submissions
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public listSepaSubmissions(paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).listSepaSubmissions(paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * All the unsubmitted payment transactions included in the bundle will be revoked. If some of the bundle/recurring payments have already submitted, then the revocation applies only to the remaining payments. 
     * @summary Revoke authorization (bundle)
     * @param {string} authorizationId Authorization ID
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750. Represents the Client Application, obtained via Client Credentials Grant.
     * @param {string} [xApiKey] API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public revokeAuthorization(authorizationId: string, authorization: string, xApiKey?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).revokeAuthorization(authorizationId, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Submit SEPA payment
     * @param {string} submissionId Submission ID generated by TPP. Must be unique per payment.
     * @param {string} paymentId Payment ID
     * @param {string} [xApiKey] API Key
     * @param {string} [authorization] An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: Sun, 10 Sep 2017 19:43:31 UTC
     * @param {string} [xFapiCustomerIpAddress] The PSU\&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {string} [xSandboxScenario] Sandbox only parameter to to simulate error conditions. Supported values are: * &#x60;InsufficientFunds&#x60;: Simulates condition where payer account has insufficient funds during submission of payment. * &#x60;PaymentSystemUnavailable&#x60;: Simulates error condition where payment submission ends up in Pending state. * &#x60;FutureSimulation&#x3D;&lt;DURATION&gt;&#x60;: Simulates advancement in time expressed in ISO 8601 duration (time) format (PnDTnHnMn.nS). Example: FutureSimulation&#x3D;PT24H * &#x60;PaymentFail&#x60;: Simulates payment submission failure due to unspecified reason. * &#x60;SandboxAuthorized&#x3D;&lt;authorizationId&gt;&#x60;: Simulates authorization allowing by pass of OAuth authorization flow. Used in submission of payment where payment is authorized with sandbox authorize endpoint /authorizations/:authorizationId/sandbox-authorize * &#x60;PaymentFail&#x3D;Reason&#x60;: Simulates payment submission failure due to one of following reason:     * &#x60;AccountClosed&#x60;: the payer account is closed and can not be debited from     * &#x60;InvalidPayee&#x60;: the payee account is unusable and can not be credited to     * &#x60;LimitExceeded&#x60;: account withdrawal limit exceeded * &#x60;PaymentSubmitFailed&#x60;: Simulates condition where Accepted payment is later rejected. * &#x60;PaymentSubmitSuccess&#x60;: Simulates condition where Accepted payment is successfully processed and transions to Submitted
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEPAPaymentsApi
     */
    public submitSepaPayment(submissionId: string, paymentId: string, xApiKey?: string, authorization?: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, xSandboxScenario?: string, body?: object, options?: any) {
        return SEPAPaymentsApiFp(this.configuration).submitSepaPayment(submissionId, paymentId, xApiKey, authorization, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, xSandboxScenario, body, options)(this.axios, this.basePath);
    }

}


/**
 * SandboxOnlyFeaturesApi - axios parameter creator
 * @export
 */
export const SandboxOnlyFeaturesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary This endpoint can be used in sandbox to authorize payment directly, skipping OAuth.
         * @param {string} authorizationId Authorization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxAuthorize(authorizationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling sandboxAuthorize.');
            }
            const localVarPath = `/authorizations/{authorizationId}/sandbox-authorize`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint can be used in sandbox to reject payment directly, skipping OAuth.
         * @param {string} authorizationId Authorization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxReject(authorizationId: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling sandboxReject.');
            }
            const localVarPath = `/authorizations/{authorizationId}/sandbox-reject`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SandboxOnlyFeaturesApi - functional programming interface
 * @export
 */
export const SandboxOnlyFeaturesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary This endpoint can be used in sandbox to authorize payment directly, skipping OAuth.
         * @param {string} authorizationId Authorization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxAuthorize(authorizationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = SandboxOnlyFeaturesApiAxiosParamCreator(configuration).sandboxAuthorize(authorizationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary This endpoint can be used in sandbox to reject payment directly, skipping OAuth.
         * @param {string} authorizationId Authorization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxReject(authorizationId: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Authorization> {
            const localVarAxiosArgs = SandboxOnlyFeaturesApiAxiosParamCreator(configuration).sandboxReject(authorizationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SandboxOnlyFeaturesApi - factory interface
 * @export
 */
export const SandboxOnlyFeaturesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary This endpoint can be used in sandbox to authorize payment directly, skipping OAuth.
         * @param {string} authorizationId Authorization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxAuthorize(authorizationId: string, options?: any) {
            return SandboxOnlyFeaturesApiFp(configuration).sandboxAuthorize(authorizationId, options)(axios, basePath);
        },
        /**
         * 
         * @summary This endpoint can be used in sandbox to reject payment directly, skipping OAuth.
         * @param {string} authorizationId Authorization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxReject(authorizationId: string, options?: any) {
            return SandboxOnlyFeaturesApiFp(configuration).sandboxReject(authorizationId, options)(axios, basePath);
        },
    };
};

/**
 * SandboxOnlyFeaturesApi - object-oriented interface
 * @export
 * @class SandboxOnlyFeaturesApi
 * @extends {BaseAPI}
 */
export class SandboxOnlyFeaturesApi extends BaseAPI {
    /**
     * 
     * @summary This endpoint can be used in sandbox to authorize payment directly, skipping OAuth.
     * @param {string} authorizationId Authorization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandboxOnlyFeaturesApi
     */
    public sandboxAuthorize(authorizationId: string, options?: any) {
        return SandboxOnlyFeaturesApiFp(this.configuration).sandboxAuthorize(authorizationId, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary This endpoint can be used in sandbox to reject payment directly, skipping OAuth.
     * @param {string} authorizationId Authorization ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SandboxOnlyFeaturesApi
     */
    public sandboxReject(authorizationId: string, options?: any) {
        return SandboxOnlyFeaturesApiFp(this.configuration).sandboxReject(authorizationId, options)(this.axios, this.basePath);
    }

}


