// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * OP confirmation of funds (CoF) service
 * Service for making confirmation of funds
 *
 * OpenAPI spec version: v1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://localhost/confirmation-of-funds-psd2/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    type?: string;
    /**
     * 
     * @type {Array<Violation>}
     * @memberof ApiError
     */
    violations?: Array<Violation>;
}

/**
 * 
 * @export
 * @interface CreateAuthorizationRequestSchema
 */
export interface CreateAuthorizationRequestSchema {
    /**
     * Specified date and time the funds confirmation authorisation will expire. If this is not defined, the authorisation will expire after a year which is the maximum valid period for single authorization. If expires value is define, it cannot exceed the maximum valid period of one year. Value is represented in ISO 8601 date-time format and it must include the timezone.
     * @type {Date}
     * @memberof CreateAuthorizationRequestSchema
     */
    expires?: Date;
    /**
     * IBAN (without formatting spaces) of the debtors account to which the confirmation of funds authorization will be applied.
     * @type {string}
     * @memberof CreateAuthorizationRequestSchema
     */
    iban?: string;
}

/**
 * 
 * @export
 * @interface CreateAuthorizationResponseSchema
 */
export interface CreateAuthorizationResponseSchema {
    /**
     * Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @type {string}
     * @memberof CreateAuthorizationResponseSchema
     */
    authorizationId?: string;
    /**
     * Date and time at which the confirmation of funds authorization was created. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof CreateAuthorizationResponseSchema
     */
    created?: Date;
    /**
     * Specified date and time the funds confirmation authorisation will expire. If this is not defined, the authorisation will expire after a year which is the maximum valid period for single authorization. If expires value is define, it cannot exceed the maximum valid period of one year. Value is represented in ISO 8601 date-time format and it must include the timezone.
     * @type {Date}
     * @memberof CreateAuthorizationResponseSchema
     */
    expires?: Date;
    /**
     * IBAN (without formatting spaces) of the debtors account to which the confirmation of funds authorization will be applied.
     * @type {string}
     * @memberof CreateAuthorizationResponseSchema
     */
    iban?: string;
    /**
     * 
     * @type {any}
     * @memberof CreateAuthorizationResponseSchema
     */
    status?: any;
}

/**
 * 
 * @export
 * @interface FundsConfirmationRequestSchema
 */
export interface FundsConfirmationRequestSchema {
    /**
     * Amount of money to be confirmed as available funds in the debtor account.
     * @type {string}
     * @memberof FundsConfirmationRequestSchema
     */
    amountEUR?: string;
    /**
     * Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @type {string}
     * @memberof FundsConfirmationRequestSchema
     */
    authorizationId?: string;
}

/**
 * 
 * @export
 * @interface FundsConfirmationResponseSchema
 */
export interface FundsConfirmationResponseSchema {
    /**
     * Amount of money to be confirmed as available funds in the debtor account.
     * @type {string}
     * @memberof FundsConfirmationResponseSchema
     */
    amountEUR?: string;
    /**
     * Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @type {string}
     * @memberof FundsConfirmationResponseSchema
     */
    authorizationId?: string;
    /**
     * Date and time at which the funds confirmation was created i.e the confirmation of funds was made. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone. Value is a positive (greater-than zero) monetary amount in currency of EUR.
     * @type {Date}
     * @memberof FundsConfirmationResponseSchema
     */
    created?: Date;
    /**
     * Flag to indicate the result of a confirmation of funds check against given amountEUR.
     * @type {boolean}
     * @memberof FundsConfirmationResponseSchema
     */
    fundsAvailable?: boolean;
    /**
     * Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation resource.
     * @type {string}
     * @memberof FundsConfirmationResponseSchema
     */
    fundsConfirmationId?: string;
}

/**
 * 
 * @export
 * @interface GetAuthorizationResponseSchema
 */
export interface GetAuthorizationResponseSchema {
    /**
     * Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @type {string}
     * @memberof GetAuthorizationResponseSchema
     */
    authorizationId?: string;
    /**
     * Date and time at which the confirmation of funds authorization was authorized. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof GetAuthorizationResponseSchema
     */
    authorized?: Date;
    /**
     * Date and time at which the confirmation of funds authorization was created. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof GetAuthorizationResponseSchema
     */
    created?: Date;
    /**
     * Specified date and time the funds confirmation authorisation will expire. If this is not defined, the authorisation will expire after a year which is the maximum valid period for single authorization. If expires value is define, it cannot exceed the maximum valid period of one year. Value is represented in ISO 8601 date-time format and it must include the timezone.
     * @type {Date}
     * @memberof GetAuthorizationResponseSchema
     */
    expires?: Date;
    /**
     * IBAN (without formatting spaces) of the debtors account to which the confirmation of funds authorization will be applied.
     * @type {string}
     * @memberof GetAuthorizationResponseSchema
     */
    iban?: string;
    /**
     * Date and time at which the confirmation of funds authorization was last modified. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof GetAuthorizationResponseSchema
     */
    modified?: Date;
    /**
     * 
     * @type {any}
     * @memberof GetAuthorizationResponseSchema
     */
    status?: any;
}

/**
 * 
 * @export
 * @interface RevokeAuthorizationResponseSchema
 */
export interface RevokeAuthorizationResponseSchema {
    /**
     * Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @type {string}
     * @memberof RevokeAuthorizationResponseSchema
     */
    authorizationId?: string;
    /**
     * Date and time at which the confirmation of funds authorization was authorized. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof RevokeAuthorizationResponseSchema
     */
    authorized?: Date;
    /**
     * Date and time at which the confirmation of funds authorization was created. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof RevokeAuthorizationResponseSchema
     */
    created?: Date;
    /**
     * Specified date and time the funds confirmation authorisation will expire. If this is not defined, the authorisation will expire after a year which is the maximum valid period for single authorization. If expires value is define, it cannot exceed the maximum valid period of one year. Value is represented in ISO 8601 date-time format and it must include the timezone.
     * @type {Date}
     * @memberof RevokeAuthorizationResponseSchema
     */
    expires?: Date;
    /**
     * IBAN (without formatting spaces) of the debtors account to which the confirmation of funds authorization will be applied.
     * @type {string}
     * @memberof RevokeAuthorizationResponseSchema
     */
    iban?: string;
    /**
     * Date and time at which the confirmation of funds authorization was last modified. All dates in the JSON payloads are represented in ISO 8601 date-time format. All date-time fields in responses must include the timezone.
     * @type {Date}
     * @memberof RevokeAuthorizationResponseSchema
     */
    modified?: Date;
    /**
     * 
     * @type {any}
     * @memberof RevokeAuthorizationResponseSchema
     */
    status?: any;
}

/**
 * Authorization's status
 * @export
 * @enum {string}
 */
export enum Status {
    Unauthorized = 'Unauthorized',
    Authorizing = 'Authorizing',
    Authorized = 'Authorized',
    Rejected = 'Rejected',
    Revoked = 'Revoked',
    Expired = 'Expired'
}

/**
 * 
 * @export
 * @interface Violation
 */
export interface Violation {
    /**
     * Location
     * @type {string}
     * @memberof Violation
     */
    location?: string;
    /**
     * Violation message
     * @type {string}
     * @memberof Violation
     */
    message?: string;
    /**
     * Path of property in error
     * @type {string}
     * @memberof Violation
     */
    path?: string;
    /**
     * Error type
     * @type {string}
     * @memberof Violation
     */
    type?: string;
}


/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create authorization request
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {CreateAuthorizationRequestSchema} [createAuthorizationRequestSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, createAuthorizationRequestSchema?: CreateAuthorizationRequestSchema, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling createAuthorization.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling createAuthorization.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createAuthorization.');
            }
            const localVarPath = `/authorizations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAuthorizationRequestSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createAuthorizationRequestSchema || {}) : (createAuthorizationRequestSchema || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get account authorization
         * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling getAuthorization.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling getAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling getAuthorization.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling getAuthorization.');
            }
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke authorization
         * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options: any = {}): RequestArgs {
            // verify required parameter 'authorizationId' is not null or undefined
            if (authorizationId === null || authorizationId === undefined) {
                throw new RequiredError('authorizationId','Required parameter authorizationId was null or undefined when calling revokeAuthorization.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling revokeAuthorization.');
            }
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling revokeAuthorization.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling revokeAuthorization.');
            }
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create authorization request
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {CreateAuthorizationRequestSchema} [createAuthorizationRequestSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, createAuthorizationRequestSchema?: CreateAuthorizationRequestSchema, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAuthorizationResponseSchema> {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).createAuthorization(authorization, accept, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, createAuthorizationRequestSchema, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Get account authorization
         * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthorizationResponseSchema> {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).getAuthorization(authorizationId, accept, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Revoke authorization
         * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevokeAuthorizationResponseSchema> {
            const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(configuration).revokeAuthorization(authorizationId, accept, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Create authorization request
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {CreateAuthorizationRequestSchema} [createAuthorizationRequestSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthorization(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, createAuthorizationRequestSchema?: CreateAuthorizationRequestSchema, options?: any) {
            return AuthorizationApiFp(configuration).createAuthorization(authorization, accept, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, createAuthorizationRequestSchema, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get account authorization
         * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return AuthorizationApiFp(configuration).getAuthorization(authorizationId, accept, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
        /**
         * 
         * @summary Revoke authorization
         * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
            return AuthorizationApiFp(configuration).revokeAuthorization(authorizationId, accept, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(axios, basePath);
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * 
     * @summary Create authorization request
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
     * @param {string} xApiKey API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
     * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {CreateAuthorizationRequestSchema} [createAuthorizationRequestSchema] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public createAuthorization(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, createAuthorizationRequestSchema?: CreateAuthorizationRequestSchema, options?: any) {
        return AuthorizationApiFp(this.configuration).createAuthorization(authorization, accept, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, createAuthorizationRequestSchema, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get account authorization
     * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} xApiKey API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
     * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AuthorizationApiFp(this.configuration).getAuthorization(authorizationId, accept, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Revoke authorization
     * @param {string} authorizationId Unique identification as assigned by the ASPSP to uniquely identify the funds confirmation authorization.
     * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {string} xApiKey API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
     * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public revokeAuthorization(authorizationId: string, accept: 'application/json', authorization: string, xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, options?: any) {
        return AuthorizationApiFp(this.configuration).revokeAuthorization(authorizationId, accept, authorization, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, options)(this.axios, this.basePath);
    }

}

/**
 * FundsConfirmationApi - axios parameter creator
 * @export
 */
export const FundsConfirmationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates funds confirmation for authorized account
         * @summary Create funds confirmation
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {FundsConfirmationRequestSchema} [fundsConfirmationRequestSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundsConfirmation(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, fundsConfirmationRequestSchema?: FundsConfirmationRequestSchema, options: any = {}): RequestArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling createFundsConfirmation.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling createFundsConfirmation.');
            }
            // verify required parameter 'xApiKey' is not null or undefined
            if (xApiKey === null || xApiKey === undefined) {
                throw new RequiredError('xApiKey','Required parameter xApiKey was null or undefined when calling createFundsConfirmation.');
            }
            const localVarPath = `/funds-confirmations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = String(accept);
            }

            if (xApiKey !== undefined && xApiKey !== null) {
                localVarHeaderParameter['x-api-key'] = String(xApiKey);
            }

            if (xFapiCustomerLastLoggedTime !== undefined && xFapiCustomerLastLoggedTime !== null) {
                localVarHeaderParameter['x-fapi-customer-last-logged-time'] = String(xFapiCustomerLastLoggedTime);
            }

            if (xFapiCustomerIpAddress !== undefined && xFapiCustomerIpAddress !== null) {
                localVarHeaderParameter['x-fapi-customer-ip-address'] = String(xFapiCustomerIpAddress);
            }

            if (xFapiInteractionId !== undefined && xFapiInteractionId !== null) {
                localVarHeaderParameter['x-fapi-interaction-id'] = String(xFapiInteractionId);
            }

            if (xCustomerUserAgent !== undefined && xCustomerUserAgent !== null) {
                localVarHeaderParameter['x-customer-user-agent'] = String(xCustomerUserAgent);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FundsConfirmationRequestSchema" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(fundsConfirmationRequestSchema || {}) : (fundsConfirmationRequestSchema || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundsConfirmationApi - functional programming interface
 * @export
 */
export const FundsConfirmationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates funds confirmation for authorized account
         * @summary Create funds confirmation
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {FundsConfirmationRequestSchema} [fundsConfirmationRequestSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundsConfirmation(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, fundsConfirmationRequestSchema?: FundsConfirmationRequestSchema, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundsConfirmationResponseSchema> {
            const localVarAxiosArgs = FundsConfirmationApiAxiosParamCreator(configuration).createFundsConfirmation(authorization, accept, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, fundsConfirmationRequestSchema, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * FundsConfirmationApi - factory interface
 * @export
 */
export const FundsConfirmationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates funds confirmation for authorized account
         * @summary Create funds confirmation
         * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
         * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
         * @param {string} xApiKey API Key
         * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
         * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
         * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
         * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
         * @param {FundsConfirmationRequestSchema} [fundsConfirmationRequestSchema] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFundsConfirmation(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, fundsConfirmationRequestSchema?: FundsConfirmationRequestSchema, options?: any) {
            return FundsConfirmationApiFp(configuration).createFundsConfirmation(authorization, accept, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, fundsConfirmationRequestSchema, options)(axios, basePath);
        },
    };
};

/**
 * FundsConfirmationApi - object-oriented interface
 * @export
 * @class FundsConfirmationApi
 * @extends {BaseAPI}
 */
export class FundsConfirmationApi extends BaseAPI {
    /**
     * Creates funds confirmation for authorized account
     * @summary Create funds confirmation
     * @param {string} authorization An Authorisation Token as per https://tools.ietf.org/html/rfc6750
     * @param {'application/json'} accept The Accept request HTTP header advertises which content types, expressed as MIME types, the client is able to understand. This header must be set to &#39;application/json&#39; or HTTP status Bad Request (400) will be returned.
     * @param {string} xApiKey API Key
     * @param {string} [xFapiCustomerLastLoggedTime] The time when the PSU last logged in with the TPP. All dates in the HTTP headers are represented as RFC 7231 Full Dates.
     * @param {string} [xFapiCustomerIpAddress] The PSU&#39;s IP address if the PSU is currently logged in with the TPP.
     * @param {string} [xFapiInteractionId] An RFC4122 UID used as a correlation id.
     * @param {string} [xCustomerUserAgent] Indicates the user-agent that the PSU is using.
     * @param {FundsConfirmationRequestSchema} [fundsConfirmationRequestSchema] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundsConfirmationApi
     */
    public createFundsConfirmation(authorization: string, accept: 'application/json', xApiKey: string, xFapiCustomerLastLoggedTime?: string, xFapiCustomerIpAddress?: string, xFapiInteractionId?: string, xCustomerUserAgent?: string, fundsConfirmationRequestSchema?: FundsConfirmationRequestSchema, options?: any) {
        return FundsConfirmationApiFp(this.configuration).createFundsConfirmation(authorization, accept, xApiKey, xFapiCustomerLastLoggedTime, xFapiCustomerIpAddress, xFapiInteractionId, xCustomerUserAgent, fundsConfirmationRequestSchema, options)(this.axios, this.basePath);
    }

}

